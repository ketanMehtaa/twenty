---
title: GraphQL Endpoints Architecture
icon: IconApi
image: /images/docs/getting-started/api.png
info: Understanding /graphql and /metadata endpoints and their differences
---

## Overview

Twenty provides two distinct GraphQL API endpoints that serve different purposes in the CRM platform. Understanding the distinction between these endpoints is crucial for effective API integration and development.

### The Two Endpoints

1. **Core API (`/graphql`)** - Dynamic workspace data operations
2. **Metadata API (`/metadata`)** - Schema configuration and data model management

```
┌─────────────────────────────────────────────────────────────┐
│                    Twenty API Server                         │
│                                                              │
│  ┌────────────────────┐         ┌────────────────────┐     │
│  │   /graphql         │         │   /metadata        │     │
│  │   (Core API)       │         │   (Metadata API)   │     │
│  │                    │         │                    │     │
│  │  - People          │         │  - Object Schema   │     │
│  │  - Companies       │         │  - Field Defs      │     │
│  │  - Tasks           │         │  - Relations       │     │
│  │  - Notes           │         │  - Indexes         │     │
│  │  - Custom Objects  │         │  - Permissions     │     │
│  └────────────────────┘         └────────────────────┘     │
│           │                               │                 │
│           ▼                               ▼                 │
│  ┌──────────────────────────────────────────────┐          │
│  │         PostgreSQL Database                   │          │
│  │  ┌──────────────┐      ┌──────────────┐     │          │
│  │  │ Workspace    │      │ Metadata     │     │          │
│  │  │ Data         │      │ Definitions  │     │          │
│  │  └──────────────┘      └──────────────┘     │          │
│  └──────────────────────────────────────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

## Core API (`/graphql`)

The Core API is a **dynamically generated GraphQL endpoint** that provides access to your workspace's actual CRM data. The schema for this endpoint is unique to each workspace and is built at runtime based on the metadata configuration.

### Key Characteristics

- **Dynamic Schema**: Generated automatically from workspace metadata
- **Data Operations**: CRUD operations on CRM entities (people, companies, tasks, etc.)
- **Workspace-Specific**: Each workspace has its own unique schema
- **Real-time**: Reflects current workspace data structure
- **Custom Objects**: Includes both standard and custom objects defined in the workspace

### Schema Generation Process

```
┌─────────────────────────────────────────────────────────────┐
│              Core API Schema Generation                      │
│                                                              │
│  1. User Authentication                                      │
│     └─▶ Extract workspace ID from JWT token                 │
│                                                              │
│  2. Metadata Retrieval                                       │
│     └─▶ Fetch object metadata from cache or database        │
│     └─▶ Include field definitions, relations, indexes       │
│                                                              │
│  3. Schema Building                                          │
│     └─▶ Generate GraphQL types from object metadata         │
│     └─▶ Create query resolvers (findOne, findMany)          │
│     └─▶ Create mutation resolvers (create, update, delete)  │
│     └─▶ Build relationship resolvers                        │
│                                                              │
│  4. Caching                                                  │
│     └─▶ Cache generated schema with metadata version        │
│     └─▶ Reuse cached schema until metadata changes          │
│                                                              │
│  5. Serve GraphQL Endpoint                                   │
│     └─▶ Execute queries against workspace database          │
└─────────────────────────────────────────────────────────────┘
```

### Available Operations

#### Queries

For each object in your workspace, the Core API generates the following query operations:

- **`findMany{Object}`** - Retrieve multiple records with filtering, sorting, and pagination
- **`findOne{Object}`** - Retrieve a single record by ID
- **`findDuplicate{Object}`** - Find duplicate records based on specified fields

**Example**: For a `person` object:
```graphql
query {
  # Find multiple people
  people(
    filter: { name: { firstName: { eq: "John" } } }
    orderBy: { createdAt: AscNullsFirst }
    first: 10
  ) {
    edges {
      node {
        id
        name {
          firstName
          lastName
        }
        email
        company {
          name
        }
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
  
  # Find a single person
  person(id: "123e4567-e89b-12d3-a456-426614174000") {
    id
    name {
      firstName
      lastName
    }
  }
}
```

#### Mutations

For each object, the following mutation operations are available:

- **`createOne{Object}`** - Create a single record
- **`createMany{Objects}`** - Create multiple records in one operation
- **`updateOne{Object}`** - Update a single record by ID
- **`updateMany{Objects}`** - Update multiple records matching criteria
- **`deleteOne{Object}`** - Soft delete a single record
- **`deleteMany{Objects}`** - Soft delete multiple records
- **`destroyOne{Object}`** - Permanently delete a single record
- **`destroyMany{Objects}`** - Permanently delete multiple records
- **`restoreOne{Object}`** - Restore a soft-deleted record
- **`restoreMany{Objects}`** - Restore multiple soft-deleted records

**Example**: Creating and updating a person:
```graphql
mutation {
  # Create a person
  createPerson(
    data: {
      name: { firstName: "Jane", lastName: "Doe" }
      email: "jane.doe@example.com"
      companyId: "company-uuid-here"
    }
  ) {
    id
    name {
      firstName
      lastName
    }
    email
  }
  
  # Update a person
  updatePerson(
    id: "person-uuid-here"
    data: {
      name: { firstName: "Jane", lastName: "Smith" }
    }
  ) {
    id
    name {
      firstName
      lastName
    }
  }
}
```

### Relationship Handling

The Core API automatically generates resolvers for relationships between objects:

```graphql
query {
  person(id: "person-uuid-here") {
    id
    name {
      firstName
      lastName
    }
    # One-to-many: Person's activities
    activities {
      edges {
        node {
          id
          title
          type
        }
      }
    }
    # Many-to-one: Person's company
    company {
      id
      name
      industry
    }
    # Many-to-many: Person's opportunities
    opportunities {
      edges {
        node {
          id
          name
          stage
        }
      }
    }
  }
}
```

### Authentication & Authorization

All requests to `/graphql` require authentication:

```http
POST /graphql
Authorization: Bearer YOUR_API_KEY
Content-Type: application/json
```

The endpoint enforces workspace-level isolation - users can only access data from their authenticated workspace.

## Metadata API (`/metadata`)

The Metadata API is a **fixed-schema GraphQL endpoint** that manages the configuration and structure of your CRM data model. This endpoint allows you to programmatically create, read, update, and delete object definitions, field definitions, relationships, and other schema configurations.

### Key Characteristics

- **Fixed Schema**: Consistent schema across all workspaces
- **Configuration Management**: Define and modify data structures
- **Administrative**: Requires elevated permissions for write operations
- **Schema Introspection**: Discover available objects and fields
- **Platform Configuration**: Manage workspace-level settings

### Use Cases

1. **Dynamic Form Building**: Fetch field definitions to build forms dynamically
2. **Integration Discovery**: Introspect available objects and fields
3. **Data Model Management**: Programmatically create custom objects and fields
4. **Schema Migration**: Automate schema changes across workspaces
5. **Admin Tools**: Build administrative interfaces for data model management

### Available Operations

#### Object Metadata Queries

The Metadata API doesn't have traditional "list all" queries. Instead, it provides field resolvers on the root type:

```graphql
query {
  # Object metadata is typically accessed through field resolvers
  # or mutations that return object metadata
}
```

#### Object Metadata Mutations

- **`createOneObject`** - Create a new custom object (Note: Standard objects are pre-defined)
- **`updateOneObject`** - Update object properties (label, description, icon, etc.)
- **`deleteOneObject`** - Delete a custom object

**Example**: Updating an object:
```graphql
mutation {
  updateOneObject(
    input: {
      id: "object-metadata-uuid"
      update: {
        labelSingular: "Customer"
        labelPlural: "Customers"
        description: "Customer information"
        icon: "IconUsers"
      }
    }
  ) {
    id
    nameSingular
    namePlural
    labelSingular
    labelPlural
    description
    icon
    isCustom
    fields {
      id
      name
      label
      type
      description
    }
  }
}
```

#### Field Metadata Operations

- **`createOneField`** - Add a new field to an object
- **`updateOneField`** - Modify field properties
- **`deleteOneField`** - Remove a field from an object

**Example**: Creating a custom field:
```graphql
mutation {
  createOneField(
    input: {
      field: {
        objectMetadataId: "object-metadata-uuid"
        type: TEXT
        name: "customField"
        label: "Custom Field"
        description: "A custom text field"
        icon: "IconTextSize"
        defaultValue: "''"
      }
    }
  ) {
    id
    name
    label
    type
    description
    icon
    isCustom
    isActive
    defaultValue
    options
  }
}
```

#### Field Types

The Metadata API supports various field types:

- `TEXT` - Single-line text
- `LONG_TEXT` - Multi-line text
- `NUMBER` - Numeric values
- `BOOLEAN` - True/false values
- `DATE_TIME` - Date and time
- `DATE` - Date only
- `EMAIL` - Email addresses
- `PHONE` - Phone numbers
- `URL` - Web URLs
- `SELECT` - Single-select dropdown
- `MULTI_SELECT` - Multi-select dropdown
- `CURRENCY` - Currency values
- `RATING` - Star ratings
- `RELATION` - Relationships to other objects
- `FULL_NAME` - Composite name field
- `ADDRESS` - Composite address field

**Example**: Creating a select field:
```graphql
mutation {
  createOneField(
    input: {
      field: {
        objectMetadataId: "object-metadata-uuid"
        type: SELECT
        name: "priority"
        label: "Priority"
        description: "Task priority level"
        options: [
          { label: "Low", value: "low", color: "green" }
          { label: "Medium", value: "medium", color: "yellow" }
          { label: "High", value: "high", color: "red" }
        ]
      }
    }
  ) {
    id
    name
    label
    type
    options {
      label
      value
      color
    }
  }
}
```

#### Relationship Management

Create relationships between objects:

```graphql
mutation {
  createOneField(
    input: {
      field: {
        objectMetadataId: "task-object-uuid"
        type: RELATION
        name: "assignee"
        label: "Assignee"
        description: "Person assigned to this task"
        relationDefinition: {
          sourceObjectMetadataId: "task-object-uuid"
          targetObjectMetadataId: "person-object-uuid"
          relationshipType: MANY_TO_ONE
        }
      }
    }
  ) {
    id
    name
    label
    type
    relationMetadata {
      id
      relationType
      fromObjectMetadata {
        id
        nameSingular
      }
      toObjectMetadata {
        id
        nameSingular
      }
    }
  }
}
```

#### Index Metadata Operations

Manage database indexes for performance optimization:

- **`createOneIndex`** - Create a new index on object fields
- **`updateOneIndex`** - Modify index properties
- **`deleteOneIndex`** - Remove an index

**Example**: Creating an index:
```graphql
mutation {
  createOneIndex(
    input: {
      objectMetadataId: "object-metadata-uuid"
      fields: ["email", "companyId"]
      isUnique: false
    }
  ) {
    id
    fields
    isUnique
    indexType
  }
}
```

### Metadata API Schema Structure

```
┌────────────────────────────────────────────────┐
│           Metadata API Schema                   │
│                                                 │
│  Query                                          │
│  └─ (No root queries - use field resolvers)    │
│                                                 │
│  Mutation                                       │
│  ├─ Object Management                           │
│  │  ├─ updateOneObject                          │
│  │  └─ deleteOneObject                          │
│  │                                              │
│  ├─ Field Management                            │
│  │  ├─ createOneField                           │
│  │  ├─ updateOneField                           │
│  │  └─ deleteOneField                           │
│  │                                              │
│  ├─ Index Management                            │
│  │  ├─ createOneIndex                           │
│  │  ├─ updateOneIndex                           │
│  │  └─ deleteOneIndex                           │
│  │                                              │
│  ├─ Remote Server (External Data)              │
│  │  ├─ createOneRemoteServer                    │
│  │  ├─ updateOneRemoteServer                    │
│  │  └─ deleteOneRemoteServer                    │
│  │                                              │
│  └─ Serverless Functions                        │
│     ├─ createOneServerlessFunction              │
│     ├─ updateOneServerlessFunction              │
│     └─ deleteOneServerlessFunction              │
│                                                 │
│  Types                                          │
│  ├─ ObjectMetadata                              │
│  ├─ FieldMetadata                               │
│  ├─ RelationMetadata                            │
│  ├─ IndexMetadata                               │
│  └─ ... (configuration types)                   │
└────────────────────────────────────────────────┘
```

### Authentication & Permissions

Metadata API requests require authentication with elevated permissions:

```http
POST /metadata
Authorization: Bearer YOUR_API_KEY
Content-Type: application/json
```

**Permission Requirements**:
- **Read operations**: Standard workspace access
- **Write operations**: Data model management permissions (admin/owner role)

## Key Differences

| Aspect | Core API (`/graphql`) | Metadata API (`/metadata`) |
|--------|----------------------|---------------------------|
| **Purpose** | Access and manipulate CRM data | Configure data model and schema |
| **Schema** | Dynamic, workspace-specific | Fixed, consistent across workspaces |
| **Data** | Actual records (people, companies, etc.) | Object/field definitions, configurations |
| **Generation** | Runtime generation based on metadata | Pre-defined schema |
| **Caching** | Schema cached per workspace | Schema defined at compile-time |
| **Use Case** | Daily operations, integrations | Admin tools, dynamic forms, migrations |
| **Permissions** | Standard workspace access | Elevated permissions for writes |
| **Examples** | Create person, update company | Add custom field, create object |

## Implementation Architecture

### Core API Implementation

The Core API is implemented using the following key components:

1. **WorkspaceSchemaFactory**: Generates the GraphQL schema for each workspace
2. **WorkspaceGraphQLSchemaGenerator**: Builds GraphQL types from object metadata
3. **WorkspaceResolverFactory**: Creates resolvers for queries and mutations
4. **WorkspaceQueryRunner**: Executes queries against the database

```typescript
// Simplified flow
class WorkspaceSchemaFactory {
  async createGraphQLSchema(authContext: AuthContext): Promise<GraphQLSchema> {
    // 1. Get workspace metadata
    const objectMetadataMaps = await this.getMetadata(authContext.workspace.id);
    
    // 2. Generate GraphQL schema
    const typeDefs = await this.generateTypeDefs(objectMetadataMaps);
    
    // 3. Create resolvers
    const resolvers = await this.createResolvers(objectMetadataMaps);
    
    // 4. Build executable schema
    return makeExecutableSchema({ typeDefs, resolvers });
  }
}
```

### Metadata API Implementation

The Metadata API is implemented using:

1. **MetadataGraphQLApiModule**: NestJS module for metadata operations
2. **ObjectMetadataResolver**: Handles object-level operations
3. **FieldMetadataResolver**: Handles field-level operations
4. **RelationMetadataResolver**: Manages relationships
5. **IndexMetadataResolver**: Manages indexes

```typescript
// Example resolver structure
@Resolver(() => FieldMetadataDTO)
export class FieldMetadataResolver {
  @Mutation(() => FieldMetadataDTO)
  async createOneField(
    @Args('input') input: CreateOneFieldMetadataInput,
    @AuthWorkspace() workspace: Workspace,
  ) {
    // Validate permissions
    // Create field in metadata tables
    // Trigger database migration
    // Invalidate schema cache
    return createdField;
  }
}
```

## Request Flow Diagrams

### Core API Request Flow

```
┌──────────┐
│  Client  │
└────┬─────┘
     │ POST /graphql
     │ { query: "{ people { id name } }" }
     ▼
┌──────────────────┐
│  Authentication  │
│  & Authorization │
└────┬─────────────┘
     │ Extract workspace ID
     ▼
┌──────────────────┐
│  Schema Factory  │
│  Get/Create      │
│  Workspace Schema│
└────┬─────────────┘
     │ Load from cache or generate
     ▼
┌──────────────────┐
│  GraphQL Engine  │
│  Parse & Validate│
└────┬─────────────┘
     │ Valid query
     ▼
┌──────────────────┐
│  Resolver        │
│  Execution       │
└────┬─────────────┘
     │ Execute database query
     ▼
┌──────────────────┐
│  Database        │
│  (Workspace Data)│
└────┬─────────────┘
     │ Return results
     ▼
┌──────────────────┐
│  Response        │
│  Formatting      │
└────┬─────────────┘
     │ JSON response
     ▼
┌──────────┐
│  Client  │
└──────────┘
```

### Metadata API Request Flow

```
┌──────────┐
│  Client  │
└────┬─────┘
     │ POST /metadata
     │ { mutation: "createOneField(...)" }
     ▼
┌──────────────────┐
│  Authentication  │
│  & Permission    │
│  Check           │
└────┬─────────────┘
     │ Verify admin permissions
     ▼
┌──────────────────┐
│  Metadata        │
│  Resolver        │
└────┬─────────────┘
     │ Validate input
     ▼
┌──────────────────┐
│  Metadata        │
│  Service         │
└────┬─────────────┘
     │ Create/Update metadata record
     ▼
┌──────────────────┐
│  Migration       │
│  Builder         │
└────┬─────────────┘
     │ Generate SQL migration
     ▼
┌──────────────────┐
│  Database        │
│  (Schema Update) │
└────┬─────────────┘
     │ Apply migration
     ▼
┌──────────────────┐
│  Cache           │
│  Invalidation    │
└────┬─────────────┘
     │ Clear workspace schema cache
     ▼
┌──────────────────┐
│  Response        │
│  (Updated        │
│   Metadata)      │
└────┬─────────────┘
     │ JSON response
     ▼
┌──────────┐
│  Client  │
└──────────┘
```

## Caching Strategy

### Core API Caching

```
┌────────────────────────────────────────────────────────┐
│            Workspace Schema Cache                       │
│                                                         │
│  Cache Key: workspace_{id}_schema_v{metadataVersion}   │
│                                                         │
│  1. Request arrives for workspace                       │
│  2. Check cache for schema with current metadata version│
│  3. If cached: return cached schema (fast path)         │
│  4. If not cached:                                      │
│     - Generate schema from metadata                     │
│     - Store in cache with metadata version              │
│     - Return schema                                     │
│                                                         │
│  Cache Invalidation:                                    │
│  - When metadata changes (field added, object updated)  │
│  - Metadata version increments                          │
│  - New schema generated on next request                 │
└────────────────────────────────────────────────────────┘
```

### Metadata API Caching

```
┌────────────────────────────────────────────────────────┐
│         Metadata Query Result Cache                     │
│                                                         │
│  Cache Key: ObjectMetadataItems                         │
│                                                         │
│  Caching Strategy:                                      │
│  - Cache introspection queries                          │
│  - Short TTL (frequently updated)                       │
│  - Invalidate on any metadata mutation                  │
│                                                         │
│  Operations:                                            │
│  - Read operations: may use cache                       │
│  - Write operations: bypass cache + invalidate          │
└────────────────────────────────────────────────────────┘
```

## Best Practices

### When to Use Core API

✅ **Use Core API (`/graphql`) for:**
- Fetching CRM records (people, companies, tasks)
- Creating and updating data in your CRM
- Building integrations with external systems
- Implementing synchronization workflows
- Building custom dashboards and reports
- Mobile app data access
- Webhook-triggered operations

### When to Use Metadata API

✅ **Use Metadata API (`/metadata`) for:**
- Building dynamic forms that adapt to schema
- Creating admin/configuration interfaces
- Implementing multi-tenant schema management
- Automated schema migrations
- Discovery of available fields and objects
- Custom field creation by users
- Building schema visualization tools

### Common Patterns

#### Pattern 1: Dynamic Form Generation

```graphql
# 1. Fetch object metadata
query GetObjectFields {
  # Accessed through mutations or specialized queries
}

# 2. Use the metadata to build a form UI
# 3. Submit data via Core API
mutation CreateRecord($data: PersonCreateInput!) {
  createPerson(data: $data) {
    id
    name
  }
}
```

#### Pattern 2: Schema Discovery for Integration

```graphql
# 1. Discover available objects via Metadata API
# 2. For each object, get field definitions
# 3. Build integration mapping
# 4. Use Core API for data sync
```

#### Pattern 3: Custom Field Management

```graphql
# 1. User requests to add field via UI
mutation AddCustomField {
  createOneField(
    input: {
      field: {
        objectMetadataId: "..."
        type: TEXT
        name: "customField"
        label: "My Custom Field"
      }
    }
  ) {
    id
    name
  }
}

# 2. Schema cache automatically invalidates
# 3. Next Core API request sees new field
query GetDataWithNewField {
  people {
    edges {
      node {
        id
        name
        customField  # Now available!
      }
    }
  }
}
```

## Error Handling

### Core API Errors

```graphql
# Example error response
{
  "errors": [
    {
      "message": "Record not found",
      "locations": [{ "line": 2, "column": 3 }],
      "path": ["person"],
      "extensions": {
        "code": "NOT_FOUND",
        "exception": {
          "recordId": "123e4567-e89b-12d3-a456-426614174000"
        }
      }
    }
  ],
  "data": {
    "person": null
  }
}
```

Common error codes:
- `UNAUTHENTICATED` - Missing or invalid authentication
- `FORBIDDEN` - Insufficient permissions
- `NOT_FOUND` - Record does not exist
- `VALIDATION_ERROR` - Invalid input data
- `INTERNAL_SERVER_ERROR` - Server-side error

### Metadata API Errors

```graphql
# Example error response
{
  "errors": [
    {
      "message": "Field name already exists",
      "extensions": {
        "code": "CONFLICT",
        "exception": {
          "fieldName": "email",
          "objectId": "object-uuid"
        }
      }
    }
  ]
}
```

Common error codes:
- `FORBIDDEN_EXCEPTION` - Insufficient permissions for metadata changes
- `CONFLICT` - Field/object name already exists
- `INVALID_FIELD_INPUT` - Invalid field configuration
- `FIELD_MUTATION_NOT_ALLOWED` - Cannot modify standard fields
- `OBJECT_METADATA_NOT_FOUND` - Target object doesn't exist

## Performance Considerations

### Core API Performance

**Optimization Tips**:
1. **Use field selection**: Only query fields you need
2. **Implement pagination**: Use `first`/`after` for large result sets
3. **Leverage filtering**: Apply filters on the server side
4. **Batch operations**: Use `createMany`/`updateMany` when possible
5. **Connection pooling**: Reuse connections for multiple queries

```graphql
# Good: Selective fields with pagination
query {
  people(first: 20) {
    edges {
      node {
        id
        name
        email
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}

# Avoid: Requesting all fields with deep nesting
query {
  people {
    edges {
      node {
        # ... all fields
        company {
          # ... all fields
          activities {
            edges {
              node {
                # ... all fields
              }
            }
          }
        }
      }
    }
  }
}
```

### Metadata API Performance

**Optimization Tips**:
1. **Minimize metadata changes**: Schema changes trigger cache invalidation
2. **Batch field creation**: Create multiple fields in sequence if needed
3. **Schema versioning**: Metadata version tracks changes for cache efficiency
4. **Avoid polling**: Use webhooks for metadata change notifications

## Security Considerations

### Authentication

Both endpoints require API key authentication:

```bash
# Generate API key from Twenty UI
# Settings → APIs & Webhooks → Generate API Key

# Use in requests
curl -X POST https://api.twenty.com/graphql \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"query": "{ people { edges { node { id name } } } }"}'
```

### Authorization

- **Core API**: Workspace-level access control
- **Metadata API**: Requires admin/owner role for write operations

### Rate Limiting

Both endpoints are subject to rate limiting:
- Default: 100 requests per minute per API key
- Configurable via environment variables
- Returns `429 Too Many Requests` when exceeded

## GraphQL Playground

Twenty provides an interactive GraphQL playground for both endpoints:

### Accessing the Playground

1. **Development Mode**: Automatically available at:
   - Core API: `http://localhost:3000/graphql`
   - Metadata API: `http://localhost:3000/metadata`

2. **Production**: Available through Settings → APIs & Webhooks

### Features

- Schema introspection and documentation
- Query/mutation autocomplete
- Query history
- Variable editor
- Response formatting

## Troubleshooting

### Common Issues

#### Issue: "Schema not found for workspace"

**Cause**: Workspace metadata not properly initialized or cached

**Solution**:
```bash
# Sync metadata
npx nx run twenty-server:command workspace:sync-metadata -f

# Clear cache and restart
redis-cli FLUSHDB
```

#### Issue: "Field not found in schema"

**Cause**: Schema cache is stale after metadata change

**Solution**: Wait a few seconds for cache invalidation, or manually clear cache

#### Issue: "Insufficient permissions for metadata operation"

**Cause**: User doesn't have admin/owner role

**Solution**: Verify user role in workspace settings

#### Issue: "Migration failed during field creation"

**Cause**: Database schema change failed

**Solution**: Check server logs for specific SQL error; may need to rollback and retry

## Advanced Topics

### Custom Resolvers

For advanced use cases, you can extend the Core API with custom resolvers through serverless functions.

### Schema Stitching

Combine Twenty's GraphQL endpoints with other GraphQL services using schema stitching or federation.

### Subscriptions

Real-time updates are available through webhooks rather than GraphQL subscriptions.

## API Evolution

### Versioning Strategy

- **Core API**: Schema evolves with workspace metadata (no version in URL)
- **Metadata API**: Fixed schema with backward-compatible changes
- **Breaking Changes**: Announced in release notes with migration guides

### Deprecation Policy

- Deprecated fields marked in schema with `@deprecated` directive
- Minimum 6-month notice before removal
- Migration guides provided for deprecated features

## Related Documentation

- [REST API Reference](/developers/api-and-webhooks/api)
- [Webhooks](/developers/api-and-webhooks/webhooks)
- [Authentication](/developers/api-and-webhooks/authentication)
- [GraphQL Best Practices](/developers/graphql-apis)
- [REST API Best Practices](/developers/rest-apis)

## Summary

Understanding the distinction between Twenty's two GraphQL endpoints is crucial:

- **Use `/graphql`** for daily operations with CRM data
- **Use `/metadata`** for schema configuration and dynamic integrations
- Both endpoints work together to provide a flexible, extensible CRM platform

The Core API adapts to your workspace configuration, while the Metadata API controls that configuration. Together, they enable powerful integrations and customizations while maintaining data integrity and performance.
